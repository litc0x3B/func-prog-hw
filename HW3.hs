{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}
{-# HLINT ignore "Use camelCase" #-}
module HW3 where

-------------------------------------------------------------------------------
-- Упр. 1: Установите интерпретатор ghci


-------------------------------------------------------------------------------
-- Упр. 2: Вычислите в интерпретаторе следующие выражения:
--         a.  1 + 1
--         b.  True == False 
--         c.  5 + 7 * (-7 + 1)
--         d.  not True
--         e.  False && True || True
--         f.  2 * 2 /= 4
--         g.  succ 9
--         h.  max 5 15 + 4 + min 9 (-1)
-- Также определите в интерпретаторе их тип (:t <exp>). 
-- Заполните: 
--    answer2(буква): строка - результат в интерпреторе.
--    answer2(буква)Type: строка - тип выражения в интерпретаторе.


answer2a :: String
answer2a = "2"
answer2aType :: String
answer2aType = "Num a => a"

answer2b :: String
answer2b = "False"
answer2bType :: String
answer2bType = "Bool"

answer2c :: String
answer2c = "-37"
answer2cType :: String
answer2cType = "Num a => a"

answer2d :: String
answer2d = "False"
answer2dType :: String
answer2dType = "Bool"

answer2e :: String
answer2e = "True"
answer2eType :: String
answer2eType = "Bool"

answer2f :: String
answer2f = "False"
answer2fType :: String
answer2fType = "Bool"

answer2g :: String
answer2g = "10"
answer2gType :: String
answer2gType = "(Enum a, Num a) => a"

answer2h :: String
answer2h = "18"
answer2hType :: String
answer2hType = "(Ord a, Num a) => a"

-------------------------------------------------------------------------------
-- Упр. 3: Укажите эквивалент в языке Haskell следующего C/Java/Python выражения:
--              combine(prettify(lawn),construct(house,concrete))
--         a. combine prettify (lawn) construct (house concerete)
--         b.  combine (prettify lawn (counstruct house concrete))
--         c.  combine (prettify lawn) (construct house concrete)


answer3 :: Char
answer3 = 'c'


-------------------------------------------------------------------------------
-- Упр. 4: Какой эквивалент C/Java/Python для Haskell выражения:
--              send metric (double population + increase)
--         a.  send(metric(double(population+increase)))
--         b.  send(metric(double(population)+increase))
--         c.  send(metric,double(population)+increase)
--         d.  send(metric,double(population+increase))


answer4 :: Char
answer4 = undefined

-------------------------------------------------------------------------------
-- Упр. 5: Используя только функцию max из модуля Prelude:
--              max :: Int -> Int -> Int
--              max x y = `если x > y, то x, иначе y`
--         напишите выражение,  которые  находит  максимальное  число  среди 
--         списка чисел:
--              0, -2, 99, 11, -5, 6, 1521


answer5 :: Int
answer5 = max 0 $ max (-2) $ max 99 $ max 11 $  max (-5) $ max 6 1521


-------------------------------------------------------------------------------
-- Упр. 6: Создайте модуль FACTORIAL:
--            module FACTORIAL where
--            
--            fac :: Int -> Int
--            fac 0 = 1
--            fac n = n * fac (n - 1)
--
-- Загрузите модуль в интерпретатор, использую команду: 
--    :load `имя_файла_модуля`
-- Команда :load будет искать указанный файл в текущем каталоге.


-- Упр. 7: Вычислите fac 5. К решению приложите файл с модулем FACTORIAL.


answer7 :: Int
answer7 = 120


-------------------------------------------------------------------------------
-- Упр. 8: Используя условное выражение напишите функцию, которая возвращает False,
-- если её аргумент больше 5, иначе возвращает True


isLessThanFive :: Integer -> Bool
isLessThanFive n = if n > 5 then False else True


-------------------------------------------------------------------------------
-- Упр. 9: Напишите функцию isZero, которая получает значение типа Integer 
-- и возвращает True, если полученное значение равно 0 и False иначе. Укажите 
-- сигнатуру функции isZero.

-- Примечания: 
--   a. Используйте только сравнение с образцом, не используйте функцию сравнения.
--   b. Тип логических значений в Haskell – это Bool.
--   c. Сигнатура в Haskell имеет вид: 
--                    имя_определения :: тип определения

-- isZero :: ?
isZero 0 = True
isZero n = False
isZeroSignature :: String
isZeroSignature = "isZero :: (Eq a, Num a) => a -> Bool"


-------------------------------------------------------------------------------
-- Упр. 10: Реализуйте функцию max', которая находит максимальное число из 3-х 
-- заданных чисел.


max' :: Int -> Int -> Int -> Int
max' a b c = max a $ max b c


-------------------------------------------------------------------------------
-- Упр. 11: Напишите выражение, которое конкатенирует строки: 
--             “Hello”, “ ”, “world”, “!”.


answer11 :: String
answer11 = "Hello" ++ " " ++ "world" ++ "!"


-------------------------------------------------------------------------------
-- Упр. 12: Используя команду :info (++) определите ассоциативность 
-- оператора (++).
--  a. Левоассоциативная
--  b. Пароассоциативная
--  c. Ассоциативная


answer12 :: Char
answer12 = 'c'


-------------------------------------------------------------------------------
-- Упр. 13: Используя команды :info (++) и :info (^) определите какой оператор 
-- имеет больший приоритет (++) или (^). 
--  a. (++)
--  b. (^)


answer13 :: Char
answer13 = 'b'


-------------------------------------------------------------------------------
-- Упр. 14: Расставьте скобки в выражении 2^4 + 6 * 3^2 – 1, в соответствии с 
-- приоритетом операций в Haskell
--
-- Примечание: в качестве ответа запишите получившееся выражение.


answer14 :: String
answer14 = "(((2^4) + (6 * (3^2))) - 1)"


-------------------------------------------------------------------------------
-- Упр. 15. Используя команду :t `выражение` определите тип
--   a.  функции max;
--   b.  функции head;
--   c.  выражения 2 + 2;
--   d.  оператора (^). 


answer15a :: String
answer15a = "Ord a => a -> a -> a"
answer15b :: String
answer15b = "GHC.Stack.Types.HasCallStack => [a] -> a"
answer15c :: String
answer15c = "Num a => a"
answer15d :: String
answer15d = "(Num a, Integral b) => a -> b -> a"


-------------------------------------------------------------------------------
-- Упр. 16: Запишите все операторы в выражениях в префиксной нотации:
--   a.  1 + 2
--   b.  4^2 – 1
--   c.  5 == 6 - 1


answer16a :: String
answer16a = "(+) 1 2"
answer16b :: String
answer16b = "(-) ((^) 4 2) 1"
answer16c :: String
answer16c = "(==) 5 ((-) 6 1)"


-------------------------------------------------------------------------------
-- Упр. 17: Запишите все операторы выражениях в инфиксной нотации:
--   a.  max 5 (-1)
--   b.  min (min 5 2) (max (-1) 4)


answer17a :: String
answer17a = "5 `max` (-1)"
answer17b :: String
answer17b = "(5 `min` 2) `min` ((-1) `max` (4))"


-------------------------------------------------------------------------------
-- Упр. 18: Запишите список чисел:
--   a. [2,3,4,5] без перечисления всех элементов списка.
--   b. [1,3,5,7,9] без перечисления всех элементов списка.


answer18a :: String
answer18a = "[2..5]"
answer18b :: String
answer18b = "[1..9]"


-------------------------------------------------------------------------------
-- Упр. 19: Напишите выражение, которое вычисляет из списка [1, 5, -3, 3, 5]:
--   a.  голову списка;
--   b.  хвост списка;
--   c.  новый список, который состоит из первых трёх элементов списка;
--   d.  новый список, который состоит из квадратов элементов списка (используйте, генераторы списка)
--   e.  новый список, который содержит умноженные на 2 элементы списка, которые при умножении на три больше 8.


answer19a :: String
answer19a = "head [1, 5, -3, 3, 5]"
answer19b :: String
answer19b = "tail [1, 5, -3, 3, 5]"
answer19c :: String
answer19c = "take 3 [1, 5, -3, 3, 5]"
answer19d :: String
answer19d = "[x^2 | x <- [1, 5, -3, 3, 5]]"
answer19e :: String
answer19e = "[x * 2 | x <- [1, 5, -3, 3, 5], x * 3 > 8]"


-- Упр. 20: Напишите функцию, которая для данного числа n создаёт список всех 
--  попарных сумм чисел от 1 до n (Т.е. [1+1, 1+2, 1+3,…,1+n, 2+1, 2+2,…,n+n] 
--  всего n*n элементов)
--
-- Примечание: Используйте генераторы списков.


answer20 :: Int -> [Int]
answer20 n = [x + y | x <- [1..n], y <- [1..n]]


-------------------------------------------------------------------------------
-- Упр. 21: Перепишите функцию используя охранные выражения:
--
--   f :: Int -> Int -> Int
--   f x y =
--     if x > y + 1      then 0 else 
--     if x > y - 2      then 1 else 
--     if x * 2  == y + 1 then 2 else
--     if x + 10 == y - 2 then 3 else 4
--
--  Используйте конструкцию where, чтобы ввести локальные определения для 
--  подвыражений y + 1 и y – 2

f :: Int -> Int -> Int
f x y
    | x > y1 = 0
    | x > y2 = 1
    | x * 2 == y1 = 2
    | x + 10 == y2 = 3
    where
        y1 = y + 1
        y2 = y - 2


-------------------------------------------------------------------------------
-- Упр. 22: Используя сравнение с образцом реализуйте функции:


fst' :: (a, b, c) -> a
fst' (a, b, c) = a

snd' :: (a, b, c) -> b
snd' (a, b, c) = b

thd' :: (a, b, c) -> c
thd' (a, b, c) = c


-------------------------------------------------------------------------------
-- Упр. 23: Напишите функцию distance, которая получает четыре значения типа 
-- Dobule: x1, y1, x2, y2 и возвращает евклидовое расстояние между двумя 
-- точками (x1, y1) и (x2, y2). Укажите сигнатуру функции distance. (куда указать?)


distance :: Double -> Double -> Double -> Double -> Double
distance x1 y1 x2 y2 = sqrt ((x2 - x1) ^ 2 + (y2 - y1) ^ 2)


-------------------------------------------------------------------------------
-- Упр. 24: Напишите  функцию add_and_double,  которая складывает два  числа, а 
-- затем умножает результат сложения на два.

add_and_double :: Int -> Int -> Int
add_and_double x y = (x + y) * 2


-------------------------------------------------------------------------------
-- Упр. 25: Используя  функцию add_and_double  реализуйте инфиксный оператор +*, 
-- который делает тоже самое, что и функция add_and_double.


(+*) :: Int -> Int -> Int
(+*) = add_and_double


-------------------------------------------------------------------------------
-- Упр. 26: Напишите функцию solve_quadratic_equation от трёх аргументов 
-- a, b и c, которые являются коэффициентами квадратного уравнения 
-- x2 + b x + c = 0. a, b, c, и x должны быть типа  Double. Результатом должна 
-- быть пара корней уравнения (кортеж двух значений). В случае комплексных 
-- корней, применение функции sqrt (находит квадратный корень) к отрицательному 
-- числу вернёт NaN (Not A Number). Используйте let-выражение или конструкцию 
-- where для определения квадратного корня дискриминанта уравнения. 


solve_quadratic_equation :: Double -> Double -> Double -> (Double, Double)
solve_quadratic_equation a b c =
    let d = sqrt (b * b - 4 * a * c)
    in ((-b + d) / (2 * a), (-b - d) / (2 * a))

-------------------------------------------------------------------------------
-- Упр. 27: Определите функцию  double_factorial, которая получает целое число n 
-- и вычисляет произведение всех факториалов начиная с нуля и включая n. 
-- Используйте let-выражения или конструкцию where для определения функции 
-- факториала.


double_factorial :: Integer -> Integer
double_factorial n =
    let fact 0 = 1
        fact n = n * fact (n - 1)
    in product [fact x | x <- [0..n]]


-------------------------------------------------------------------------------
-- Упр. 28: Напишите  функцию ilog3. Функция должна вычислять сколько  раз можно 
-- полученное значение аргумента разделить на 3 (с округлением в меньшую сторону) 
-- прежде, чем будет получен 0.
--
-- Пример:
--   ilog3 20 ==> 3 т.к.
--     --   20/3 = 6.66 (округляется до 6)
-- --   6/3 = 2
-- --   2/3 = 0.666 (округляется до 0)
-- ilog3 2 ==> 1
-- ilog3 7 ==> 2
--
-- Используйте функцию целочисленного деления div для деления целых чисел. 

ilog3 :: Integer -> Integer
ilog3 n = 
    let ilog3' 0 ans = ans
        ilog3' n ans = ilog3' (n `div` 3) (ans + 1)
    in ilog3' n 0