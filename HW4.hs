module HW4 where

import Control.Monad
import qualified Data.ByteString.Char8 as C

-------------------------------------------------------------------------------
-- Упр. 1: Реализовать функцию pascal c r  для вычисления значений из 
-- треугольника паскаля. Здесь c – это номер столбца, а r – номер строки. 
-- Столбцы и строки отсчитываются начиная с нуля. 
--
-- Примеры:
--   pascal 0 2 = 1
--   pascal 1 2 = 2
--   pascal 2 4 = 6


pascal :: Int -> Int -> Int
pascal c r
  | (c == 0 || c == r) = 1
  | otherwise = pascal (c - 1) (r - 1) + pascal c (r - 1)

-- возвращает строковое представление первых n строчек треугольника паскаля.
printIt :: Int -> C.ByteString
printIt n = C.pack $ show $ [pascal y x | x <- [0..n], y <- [0..x]]

-- печатает первые n строчек треугольника паскаля в консоль.
printItIo :: Int -> IO ()
printItIo n = mapM_ print [[pascal y x | y <- [0..x]] | x <- [0..n]]


-------------------------------------------------------------------------------
-- Упр. 3: Реализуйте функцию, которая находит наибольший общий делитель своих 
-- аргументов.


gcd'::Int->Int->Int
gcd' i1 i2 = head $ filter (\x -> i1 `mod` x == 0 && i2 `mod` x == 0) $ reverse [1..(min i1 i2)]

-------------------------------------------------------------------------------
-- Упр. 4: Реализуйте функцию delete, которая принимает на вход строку и 
-- символ и возвращает строку, в которой удалены все вхождения символа.

-- Пример:
--   delete ’l’ "Hello world!"  ==> "Heo word!"


delete :: Char -> String -> String
delete ch str = filter (\x -> x /= ch) str

-------------------------------------------------------------------------------
-- Упр. 5: Реализуйте функцию substitute, которая заменяет в строке указанный 
-- символ на заданный.

-- Пример:
--   substitute ’e’ ’i’ "eigenvalue" ==> "iiginvalui"


substitute :: Char -> Char -> String -> String
substitute ch1 ch2 str = map (\x -> if x == ch1 then ch2 else x) str

-------------------------------------------------------------------------------
-- Упр. 6: Реализуйте с использованием хвостовой рекурсии функцию reverse', 
-- которая обращает список. 

-- Замечание : Все необходимые вспомогательные функции должны быть определены 
-- при помощи let-выражений.

-- Пример:
-- reverse' [] ==> []
-- reverse' [1,6,4,2] => [2,4,6,1]


reverse' :: [a] -> [a]
reverse' xs = 
    let aux acc [] = acc
        aux acc (y:ys) = aux (y : acc) ys
    in aux [] xs
-------------------------------------------------------------------------------
-- Упр. 7: Не используя какие-либо встроенные функции, реализуйте с 
-- использование хвостовой рекурсии функцию assoc.
-- Такую, что 
--   assoc def key [(k1,v1), (k2,v2), (k3,v3);...])
-- ищет первое i, такое что ki = key. Если такое ki было найдено, то значение 
-- функции – vi, иначе значение функции равно def.

-- Примеры:
--   assoc 0 "william" [("ranjit", 85), ("william",23), ("moose",44)] ==> 23
--   assoc 0 "bob" [("ranjit",85), ("william",23), ("moose",44)]      ==> 0


assoc :: Int -> String -> [(String, Int)] -> Int
assoc def key [] = def
assoc def key ((k, v):xs)
  | k == key = v
  | otherwise = assoc def key xs

-------------------------------------------------------------------------------
-- Упр. 8: Напишите рекурсивную функцию balance, проверяющую 
-- балансировку скобок в строке. 
-- Как вы должны помнить, строки в Haskell — это список символов [Char].
-- Например, для следующих строк функция должна вернуть True:
--   (if (zero? x) max (/ 1 x))
--   I told him (that it’s not (yet) done). (But he wasn’t listening)
-- А для строк ниже, напротив, функция должна вернуть значение False:
--   :-)
--   ())(
-- Последний пример демонстрирует: недостаточно проверить только, что строка содержит 
-- равное количество открывающих и закрывающих скобок.


balance :: String -> Bool
balance str = 
  let balance' x:xs num 
    | x == '(' = balance


-------------------------------------------------------------------------------
-- Упр. 9.a:
-- Треугольное число – число монет, которые можно расставить в виде правильного 
-- треугольника со стороной n.
--
-- Пример:
--   n1 = 1:      o
--   
--   n2 = 3:      o
--               o o
-- 
--   n3 = 6:      o
--              o  o
--             o  o  o
-- и т.д.  
--
-- Напишите функцию, которая строит список треугольных чисел.


triangulars :: [Int]
triangulars = undefined

-------------------------------------------------------------------------------
-- Упр. 9.b: Пирамидальное число (тэтраэдальное) –  количество шариков, которые 
-- можно расположить в виде пирамиды с треугольной равносторонней гранью, на 
-- ребре которой распложено n шариков.
--
-- Напишите функцию, которая строит список пирамидальных чисел. 
-- Прямую формулу для пирамидальных чисел не использовать!


pyramidals :: [Int]
pyramidals = undefined



-------------------------------------------------------------------------------
-- Упр. 10: Напишите рекурсивную функцию, которая подсчитывает число способов 
-- разменять сумму с использованием заданного списка номиналов монет. 
-- Например, есть 3 способа разменять 4, если у вас есть монеты достоинством 
-- 1 и 2: 1+1+1+1, 1+1+2, 2+2.
-- Для выполнения задания реализуйте функцию, которая принимает сумму для 
-- размена и список уникальных номиналов монет, а возвращает число способов 
-- разменять данную сумму с использованием данных номиналов


countChange :: Int -> [Int] -> Int
countChange _ _ = undefined


-------------------------------------------------------------------------------
-- Упр. 11: Используя функции ФВП над списками: map, filter, а также 
-- вспомогательные функции, такие как sum, product, even и т.д. напишите 
-- выражение, которое:
--     a.  Вычисляет сумму квадратов элементов списка [1..10]
--     b.  Вычисляет произведение чётных чисел в списке [4,5,-2,10,11,4,5,8,6]


answer11a :: dummyType
answer11a = undefined

answer11b :: dummyType
answer11b = undefined


-------------------------------------------------------------------------------
-- Упр. 12: Перепишите выражение используя сечения:
--     a.  map (\x -> x + 5) [1..10]
--     b.  filter (\y -> 5 > y) [3..7]


answer12a :: dummyType
answer12a = undefined

answer12b :: dummyType
answer12b = undefined


-------------------------------------------------------------------------------
-- Упр. 13: Если определить тип:
--               data Potato = Tomato Int Potato (String -> Int),
-- какой тип будет у Tomato?
--      a.  Potato
--      b.  Int -> Potato -> String -> Int -> Potato
--      c.  Int -> Potato -> (String -> Int) -> Potato
--      d.  Tomato
--      e.  Int -> Potato -> (String -> Int) -> Tomato
--      f.  Int -> Potato -> String -> Int -> Tomato


answer13 :: Char
answer13 = undefined

-------------------------------------------------------------------------------
-- Упр. 14: Если определить тип:
--              data ThreeList a b c = ThreeList [a] [b] [c],
-- какой тип будет у ThreeList?
--      a.  [a] -> [b] -> [c] -> ThreeList
--      b.  a -> b -> c -> ThreeList a b c
--      c.  [a] -> [b] -> [c] -> ThreeList [a] [b] [c]
--      d.  [a] -> [b] -> [c] -> ThreeList a b c

answer14 :: Char
answer14 = undefined

-------------------------------------------------------------------------------
-- Упр. 14: Если определить тип:
--              data TwoList a b = TwoList {aList :: [a], b:List :: [b]}
-- какой тип будет у функции bList?
--      a.  bList – это не функция
--      b.  TwoList a b -> [b]
--      c.  [b] -> TwoList a b
--      d.  [b]

answer15 :: Char
answer15 = undefined


-------------------------------------------------------------------------------
-- Упр. 16: Определите тип RainbowColor, значения которого – семь цветов 
-- радуги. Параметров у конструкторов значений никаких нет.


data RainbowColor = RainbowColorUndefined

-------------------------------------------------------------------------------
-- Упр. 17: Определите тип BusTicket, который может представлять значения вида:
-- a.  SingleTicket
-- b.  MonthlyTicket "January"
-- c.  MonthlyTicket "December"


data BusTicket = BasTicketUndefined

-------------------------------------------------------------------------------
-- Упр. 18: Определите тип данных Position, который состоит из двух 
-- значений x и y типа Int. Также определите функции ниже для управления 
-- значениями типа Position.
--
-- Примеры:
--   getY (up (up origin))    ==> 2
--   getX (up (right origin)) ==> 1


data Position = PositionUndefined

-- origin – это Position с x и y равными 0
origin :: Position
origin = undefined

-- getX возвращает значение x из Position
getX :: Position -> Int
getX = undefined

-- getY возвращает значение y из Position
getY :: Position -> Int
getY = undefined

-- up увеличивает значение y у Position на 1
up :: Position -> Position
up = undefined

-- right увеличивает значение x у Position на 1
right :: Position -> Position
right = undefined


-------------------------------------------------------------------------------
-- Упр. 19: Дано определение типа данных Nat – т.н. представление Пеано для 
-- натуральных чисел. Суть представления в том, что есть константа Zero, 
-- которая соответствует нулю и функция для получения следующего числа PlusOne. 
-- Реализуйте функции fromNat и toNat, которые конвертируют значения типа Nat в Int 
-- и обратно.
--
-- Примеры:
--   fromNat (PlusOne (PlusOne (PlusOne Zero)))  ==>  3
--   toNat 3    ==> Just (PlusOne (PlusOne (PlusOne Zero)))
--   toNat (-3) ==> Nothing


data Nat = Zero | PlusOne Nat
  deriving (Show,Eq)

fromNat :: Nat -> Int
fromNat n = undefined

toNat :: Int -> Maybe Nat
toNat z = undefined


-------------------------------------------------------------------------------
-- Упр. 20: Дано определение типа данных Bin – обращенная форма бинарного 
-- представления целого числа. 
--   Конструктор O   : представляет бит ноль, а его параметр – это остальная 
--                     часть бинарного числа. 
--   Конструктор I   : представляет бит один, его параметр – это также остальная 
--                     часть бинарного числа. 
--   Конструктор End : представляет конец бинарного числа. Он не принимает 
--                     параметров.
-- Для упрощения вычислений биты бинарного числа записываются при помощи типа 
-- данных Bin в обратном порядке:
--     1011 ==> I (I (O (I End)))
--     110  ==> O (I (I End))
--     10010110 ==> O (I (I (O (I (O (O (I End)))))))
-- Реализуйте следующие функции: prettyPrint, fromBin, toBin, которые 
-- конвертируют Bin в человеко-читаемое строковое представление, 
-- Bin в Int и Int в Bin соответственно.
--
-- Примеры:
--   prettyPrint End      ==> ""  
--   prettyPrint (O End)  ==> "0"
--   prettyPrint (I End)  ==> "1"
--   prettyPrint (O (O (I (O (I End))))) ==> "10100"
--   
--   map fromBin [
--     O End, I End, 
--     O (I End), 
--     I (I End), 
--     O (O (I End)),
--     I (O (I End))
--   ] ==> [0, 1, 2, 3, 4, 5]
--       fromBin (I (I (O (O (I (O (I (O End)))))))) ==> 83
--       fromBin (I (I (O (O (I (O (I End)))))))     ==> 83
--   
--   map toBin [0..5] ==> [
--     O End,
--     I End,
--     O (I End),
--     I (I End),
--     O (O (I End)),
--     I (O (I End))
--   ]
--   toBin 57 ==> I (O (O (I (I (I End)))))


data Bin = End | O Bin | I Bin deriving (Show, Eq)

  -- функция, которая увеличивает бинарное число на один
inc :: Bin -> Bin
inc End   = I End
inc (O b) = I b
inc (I b) = O (inc b)

prettyPrint :: Bin -> String
prettyPrint = undefined

fromBin :: Bin -> Int
fromBin = undefined

toBin :: Int -> Bin
toBin = undefined